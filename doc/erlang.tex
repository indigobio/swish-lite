% Copyright 2021 Indigo BioAutomation, Inc.
% Copyright 2018 Beckman Coulter, Inc.
%
% Permission is hereby granted, free of charge, to any person
% obtaining a copy of this software and associated documentation files
% (the "Software"), to deal in the Software without restriction,
% including without limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of the Software,
% and to permit persons to whom the Software is furnished to do so,
% subject to the following conditions:
%
% The above copyright notice and this permission notice shall be
% included in all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
% EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
% NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
% BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
% ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\chapter {Erlang Embedding}\label{chap:erlang}

\section {Introduction}

This chapter describes a Scheme embedding of a tuples, pattern
matching, and other useful concepts from the Erlang programming
language~\cite{armstrong-thesis,programming-erlang}.\footnote{Tuples,
denoted by \{$e_1$, \ldots, $e_n$\} in Erlang, are implemented as
vectors: \code{\#(\var{e$_1$}~\etc~\var{e$_n$})}. Similarly records,
defined as syntactic sugar over tuples in Erlang, are implemented as
syntactic sugar over vectors.}  Tuple and pattern matching macros
provide succinct ways of composing and decomposing data structures.

\section {Programming Interface}\label{sec:erlang-api}

% ----------------------------------------------------------------------------
\subsection {Tuples}

A \emph{tuple}\index{tuple} is a container of named, immutable fields
implemented as a vector whose first element is the tuple name and
remaining elements are the fields. Each tuple definition is a macro
that provides all tuple operations using field names only, not field
indices. The macro makes it easy to copy a tuple without having to
specify the fields that don't change.  We decided not to use the
Scheme record facility because it does not provide name-based
constructors, copy operators, or convenient serialization.

% ----------------------------------------------------------------------------
\index{tuple!define-tuple@\code{define-tuple}}
\defineentry{define-tuple}
\begin{syntax}
  \code{(define-tuple \var{name} \var{field} \etc{})}
\end{syntax}
\expandsto{} a macro definition of \var{name} described below

The \code{define-tuple} macro defines a macro for creating,
copying, identifying, and accessing tuple type \var{name}. \var{name}
and \var{field} \etc{} must be identifiers. No two field names can be
the same. The following field names are reserved: \code{make},
\code{copy}, \code{copy*}, and \code{is?}.

% ----------------------------------------------------------------------------
\index{tuple!make@\code{make}}
\begin{syntax}
  \code{(\var{name} make [\var{field} \var{value}] \etc{})}
\end{syntax}
\returns{} a new instance of tuple type \var{name} with \var{field} =
\var{value} \etc{}

The \code{make} form creates a new instance of the tuple type
\var{name}. \var{field} bindings may appear in any order. All fields
from the tuple definition must be specified.

% ----------------------------------------------------------------------------
\index{tuple!field accessor}
\begin{syntax}
  \code{(\var{name} \var{field} \var{instance})}
\end{syntax}
\returns{} \var{instance}.\var{field}

The field accessor form retrieves the value of the specified
\var{field} of \var{instance}. If $r$ = \var{instance} is not a tuple
of type \var{name}, exception \code{\#(bad-tuple \var{name} $r$
  \var{src})} is raised, where \var{src} is the source location of the
field accessor form if available.

\index{tuple!field accessor}
\begin{syntax}
  \code{(\var{name} \var{field})}
\end{syntax}
\returns{} a procedure that, given \var{instance}, returns \var{instance}.\var{field}

The \code{(\var{name} \var{field})} form expands to \code{(lambda (instance) (\var{name} \var{field} instance))}.

% ----------------------------------------------------------------------------
\index{tuple!open@\code{open}}
\begin{syntax}
  \code{(\var{name} open \var{instance} \opt{\var{prefix}} (\var{field} \etc{}))}
\end{syntax}
\expandsto{} definitions for \var{field} \etc{} or \var{prefix}\var{field} \etc{} described below

The \code{open} form defines identifier syntax for each specified \var{field}
so that a reference to \var{field} expands to \code{(\var{name} \var{field} $r$)}
where $r$ is the value of \var{instance}.
If $r$ is not a tuple of type \var{name}, exception
\code{\#(bad-tuple \var{name} $r$ \var{src})} is raised, where
\var{src} is the source location of the \code{open} form if avalable.
The \code{open} form is equivalent to the following, except that it
checks the tuple type only once:
\antipar\codebegin
(begin
  (define instance \var{instance})
  (define-syntax \var{field} (identifier-syntax (\var{name} \var{field} instance)))
  \etc{})
\codeend\antipar
The \code{open} form introduces definitions only for fields listed explicitly in \code{(\var{field} \etc{})}.
If the optional \var{prefix} identifier is supplied, \code{open} produces
a definition for \code{\var{prefix}\var{field}} rather than \var{field} for
each \var{field} specified.

% ----------------------------------------------------------------------------
\index{tuple!copy@\code{copy}}
\begin{syntax}
  \code{(\var{name} copy \var{instance} [\var{field} \var{value}] \etc{})}
\end{syntax}
\returns{} a new instance of tuple type \var{name} with \var{field} =
\var{value} \etc{} and remaining fields copied from \var{instance}

The \code{copy} form creates a copy of \var{instance} except that
each specified \var{field} is set to the associated \var{value}. If
$r$ = \var{instance} is not a tuple of type \var{name}, exception
\code{\#(bad-tuple \var{name} $r$ \var{src})} is raised, where
\var{src} is the source location of the \code{copy} form if
avalable.  \var{field} bindings may appear in any order.

% ----------------------------------------------------------------------------
\index{tuple!copy*@\code{copy*}}
\begin{syntax}
  \code{(\var{name} copy* \var{instance} [\var{field} \var{value}] \etc{})}
\end{syntax}
\returns{} a new instance of tuple type \var{name} with \var{field} =
\var{value} \etc{} and remaining fields copied from \var{instance}

The \code{copy*} form is like \code{copy} except that, within the \var{value} expressions,
each specified \var{field} is bound to an identifier macro that returns the value of \var{instance.field}.
If $r$ = \var{instance} is not a tuple of type \var{name}, exception
\code{\#(bad-tuple \var{name} $r$ \var{src})} is raised, where
\var{src} is the source location of the \code{copy*} form if avalable.
The \code{copy*} form is equivalent to the following, except that it
checks the tuple type only once:
\antipar\codebegin
(let ([instance \var{instance}])
  (\var{name} open instance (\var{field} \etc{}))
  (\var{name} copy instance [\var{field} \var{value}] \etc{}))
\codeend\antipar

% ----------------------------------------------------------------------------
\index{tuple!is?@\code{is?}}
\begin{syntax}
  \code{(\var{name} is? \var{x})}
\end{syntax}
\returns{} a boolean

The \code{is?} form determines whether or not the datum \var{x} is
an instance of tuple type \var{name}.

\index{tuple!is?@\code{is?}}
\begin{syntax}
  \code{(\var{name} is?)}
\end{syntax}
\expandsto{} a predicate that returns true if and only if its argument
is an instance of tuple type \var{name}

The \code{(\var{name} is?)} form expands to \code{(lambda (x) (\var{name} is? x))}.

\index{tuple!field-index@\code{field-index}}
\begin{syntax}
  \code{(\var{name} field-index \var{field})}
\end{syntax}
\expandsto{} an integer \var{n}, such that \code{(vector-ref \var{instance} \var{n})}
returns \var{instance}.\var{field}

Avoid using this form when possible, as it leaks implementation details.

% ----------------------------------------------------------------------------
\subsection {Pattern Matching}

The pattern matching syntax of Table~\ref{tab:erlang-pattern-grammar}
provides a concise and expressive way to match data structures and
bind variables to parts. The \code{match}, \code{match-define}, and
\code{match-let*} macros use this pattern language. The implementation
makes a structurally recursive pass over the pattern to check for
duplicate pattern variables as it emits code that matches the input
against the pattern left to right.

% ----------------------------------------------------------------------------
\begin{table}
\begin{tabular}{p{1.8in}p{4.2in}}
  pattern & matches \\ \hline

  \var{symbol} & itself \\
  \var{number} & itself \\
  \var{boolean} & itself \\
  \var{character} & itself \\
  \var{string} & itself \\
  \var{bytevector} & itself \\

  \code{()} & itself \\
  \code{($p_1$ . $p_2$)} & a pair whose car matches $p_1$ and cdr
  matches $p_2$ \\

  \code{\#($p_1$ \etc{} $p_n$)} & a vector of $n$ elements whose
  elements match $p_1$ \etc{} $p_n$ \\

  \code{\#!eof} & a datum satisfying \code{eof-object?} \\

  \code{,\_} & any datum \\
  \code{,\var{variable}} & any datum and binds a fresh \var{variable} to it \\
  \code{,@\var{variable}} & any datum \code{equal?} to the bound
  \var{variable} \\

  \code{,(\var{variable} <= \var{pattern})} & any datum that
  matches \var{pattern} and binds a fresh \var{variable} to it \\

  \multicolumn{2}{l}{\code{`(\var{type} \set{,\var{field}\alt{},@\var{field}\alt{}[\var{field} \var{pattern}]} \etc{})}} \\
  &
  an instance of the tuple or native record \var{type}, each \var{field} of which is
  bound to fresh variable \var{field} or matches the corresponding
  \var{pattern};
  \code{,@\var{field}} is treated as \code{[\var{field}\ ,@\var{field}]};
  \var{type} must be known at expand time \\

  \code{`(\var{ext} \var{spec} \etc{})}
  & as specified by \code{define-match-extension} for \var{ext} \\
\hline
\end{tabular}

\caption{Pattern Grammar\label{tab:erlang-pattern-grammar}}
\end{table}

% ----------------------------------------------------------------------------
\defineentry{match}
\begin{syntax}\begin{alltt}
(match \var{exp}
  (\nt{pattern} \opt{(guard \var{g})} \var{b1} \var{b2} \etc{})
  \etc{})\strut\end{alltt}
\end{syntax}
\returns{} the value of the last expression \var{b1} \var{b2} \etc{}
for the matched pattern

The \code{match} macro evaluates \var{exp} once and tests its value
$v$ against each pattern and optional guard.  Each guard expression
\var{g} is evaluated in the scope of its associated pattern
variables. When \var{g} returns \code{\#f}, $v$ fails to match that
clause.  For the first pattern and guard that matches $v$, the
expressions \var{b1} \var{b2} \etc{} are evaluated in the scope of its
pattern variables. If $v$ fails to match all patterns, exception
\code{\#(bad-match $v$ \var{src})} is raised, where \var{src} is the
source location of the \code{match} clause if available.

See Table~\ref{tab:erlang-pattern-grammar} for the pattern grammar.

% ----------------------------------------------------------------------------
\defineentry{match-define}
\begin{syntax}
\code{(match-define \nt{pattern} \var{exp})}
\end{syntax}
\expandsto{} see below

The \code{match-define} macro evaluates \var{exp} and matches the resulting
input against the pattern.
Pattern-variable bindings are established via \code{define} and inhabit the
same scope in which the \code{match-define} form appears.
The \code{match-define} macro does not support guard expressions.
If the pattern fails to match, exception
\code{\#(bad-match $v$ \var{src})} is raised, where $v$ is the datum
that failed to match the pattern at source location \var{src}
if available.

See Table~\ref{tab:erlang-pattern-grammar} for the pattern grammar.

% ----------------------------------------------------------------------------
\defineentry{match-let*}
\begin{syntax}\begin{alltt}
(match-let* ([\nt{pattern} \opt{(guard \var{g})} \var{exp}]
             \etc{})
  \var{b1} \var{b2} \etc{})\strut\end{alltt}
\end{syntax}
\returns{} the value of the last expression \var{b1} \var{b2} \etc{}

The \code{match-let*} macro evaluates each \var{exp} in the order
specified and matches its value against its pattern and guard.  The
pattern variables of each clause extend the scope of its guard
expression \var{g} and all subsequent pattern clauses and body
expressions \var{b1} \var{b2} \etc{}.  The \code{match-let*} macro
returns the value of the last body expression.  If any pattern fails
to match or any \var{g} returns \code{\#f}, exception
\code{\#(bad-match $v$ \var{src})} is raised, where $v$ is the datum
that failed to match the pattern or guard at source location \var{src}
if available.

See Table~\ref{tab:erlang-pattern-grammar} for the pattern grammar.

% ----------------------------------------------------------------------------
\defineentry{define-match-extension}
\begin{syntax}
\code{(define-match-extension \var{ext} \var{handle-object} \opt{\var{handle-field}})}
\end{syntax}
\expandsto{} see below

The \code{define-match-extension} macro attaches a property
to the identifier \var{ext}, via \code{define-property},
so that the expander calls \var{handle-object} to translate
\code{`(\var{ext} \var{spec} \etc{})} patterns
when generating code for \code{match}, \code{match-define}, \code{match-let*},
or \code{receive}.
The \var{handle-object} procedure takes two arguments: \var{v}, an
identifier that will be bound in the generated code to the value to be
matched, and \var{pattern}, a syntax object for an expression of the form
\code{`(\var{ext} \var{spec} \etc{})}.
The \var{handle-object} procedure can return \code{\#f} to report
an invalid \var{pattern}.
Otherwise, \var{handle-object} should translate the given \var{pattern} to
a list of one or more instructions in the following simple language:

\begin{tabular}{ll}
  \code{(bind \var{v} \var{e})}
    & binds \var{v} to the value of \var{e} via \code{let} or \code{define} \\
  \code{(guard \var{g})}
    & rejects the match if \var{g} evaluates to \code{\#f} \\
  \code{(sub-match \var{e} \var{pattern})}
    & matches the value of \var{e} against \var{pattern} \\
  \code{(handle-fields \var{input} \var{field-spec} \etc{})}
    & invokes \var{handle-field} to translate each \var{field-spec}
\end{tabular}

The generated code evaluates the instructions in the order they are returned.
For example, a \code{guard} expression may refer to a binding established
by a \code{bind} earlier in the list of instructions.
The \code{sub-match} and \code{handle-fields} instructions
are processed at expand time and may appear only
as the final instruction in the list returned by \var{handle-object}.

The \code{(handle-fields \var{input} \var{field-spec} \etc{})} instruction
parses each \var{field-spec} from left to right and calls
\var{handle-field} with five arguments:
the \var{input} from the instruction,
the \var{field} identified,
the \var{var} that should be bound to the value of \var{field},
a list of \var{options} appearing in the \var{field-spec},
and the original pattern \var{context}.
The following table shows how each \var{field-spec} is parsed
into arguments for \var{handle-field}:

\begin{tabular}{lllll}
  \var{field-spec} & \var{field} & \var{var} & \var{options} & notes \\ \hline
  \code{,\var{field}} & \var{field} & \var{field} & \code{()} & \var{field} must be an identifier \\
  \code{,@\var{field}} & \var{field} & \var{unique} & \code{()} & \var{field} must be an identifier \\
  \code{[\var{field} \var{pattern} \var{option} \etc{}]} &
    \var{field} & \var{unique} & \code{(\var{option} ...)} &
    \var{unique} is matched against \var{pattern} \\
\end{tabular}

The \var{handle-field} procedure can return \code{\#f} to report an invalid
\var{field}.
Otherwise, \var{handle-field} should return a list of \code{bind} or
\code{guard} instructions that bind \var{var} and perform any checks
needed to confirm a match.
The resulting instructions are evaluated in the order they are returned.

Where temporaries are introduced in the generated output,
the \var{handle-object} and \var{handle-field} procedures should use
\code{with-temporaries} to avoid unintended variable capture.

\subsection {Exceptions}

% ----------------------------------------------------------------------------
\defineentry{catch}
\begin{syntax}
  \code{(catch \var{e1} \var{e2} \etc{})}
\end{syntax}
\expandsto{}
\code{(\$trap (lambda () \var{e1} \var{e2} \etc{}) ->EXIT)}

The \code{catch} macro evaluates expressions \var{e1} \var{e2}
\etc{} in a dynamic context that traps exceptions.  If no exception is
raised, the return value is the value of the last expression. If
exception \var{reason} is raised, \code{\#(EXIT \var{reason})} is
returned.

% ----------------------------------------------------------------------------
\defineentry{try}
\begin{syntax}
  \code{(try \var{e1} \var{e2} \etc{})}
\end{syntax}
\expandsto{}
\code{(\$trap (lambda () \var{e1} \var{e2} \etc{}) ->fault-condition)}

The \code{try} macro evaluates expressions \var{e1} \var{e2}
\etc{} in a dynamic context that traps exceptions.  If no exception is
raised, the return value is the value of the last expression. If
exception \var{reason} is raised, the return value is a fault condition
matching the extended match pattern \code{`(catch \var{reason} \opt{\var{e}})}.

% ----------------------------------------------------------------------------
\defineentry{catch}
\begin{match-extension}
  \code{`(catch \var{r} \opt{\var{e}})}
\end{match-extension}
\matches{} exceptions trapped by \code{try} or \code{catch}

The extended match pattern \code{`(catch \var{r} \opt{\var{e}})} matches
exceptions trapped by \code{try}.
For compatibility with older code, this pattern also matches exceptions
trapped by \code{catch}.
The \var{r} pattern is matched against the exit reason in the trapped exception.
The optional \var{e} pattern is typically a \code{,\var{variable}} pattern that
binds \var{variable} for use as an argument to \code{throw} or \code{raise}.
If the trapped exception is a fault condition generated by \code{throw},
\code{make-fault}, or \code{make-fault/no-cc}, then \var{e} is
matched against the fault condition, which may contain additional debugging context.
Otherwise, \var{e} is matched against the exit reason.

% ----------------------------------------------------------------------------
\defineentry{throw}
\begin{procedure}
  \code{(throw \var{r} \opt{\var{inner}})}
\end{procedure}
\returns{} does not return

The \code{throw} procedure raises a fault condition containing reason
\var{r}, an optional inner exception \var{inner}, and the current
continuation, which may provide useful debugging context.
The exception raised may be trapped by \code{try} and matched using
the extended match pattern \code{`(catch \var{r} \opt{\var{e}})}.

% ----------------------------------------------------------------------------
\defineentry{make-fault}
\begin{procedure}
  \code{(make-fault \var{r} \opt{\var{inner}})}
\end{procedure}
\returns{} a fault condition

The \code{make-fault} procedure returns a fault condition containing reason
\var{r}, an optional inner exception \var{inner}, and the current
continuation, which may provide useful debugging context.
The return value matches
the extended match pattern \code{`(catch \var{r} \opt{\var{e}})}.

% ----------------------------------------------------------------------------
\defineentry{make-fault/no-cc}
\begin{procedure}
  \code{(make-fault/no-cc \var{r} \opt{\var{inner}})}
\end{procedure}
\returns{} a fault condition

The \code{make-fault/no-cc} procedure returns a fault condition
containing reason \var{r}, and an optional inner exception \var{inner},
but omits the current continuation.
The return value matches
the extended match pattern \code{`(catch \var{r} \opt{\var{e}})}.

% ----------------------------------------------------------------------------
\defineentry{arg-check}
\begin{syntax}
  \code{(arg-check \var{who} [\var{arg} \var{pred} \ldots] \ldots)}
\end{syntax}
\expandsto{}\begin{alltt}\antipar
(let ([who \var{who}])
  (let ([arg \var{arg}])
    (unless (and (pred arg) \ldots)
      (profile-me-as arg-check)
      (bad-arg who arg)))
  \ldots
  (void))\end{alltt}

The \code{arg-check} macro raises a \code{bad-arg} exception if
any \var{arg} fails any \var{pred} specified for that \var{arg}.
Within coverage reports, profile counts on the \code{arg-check}
keyword indicate the number of \code{bad-arg} cases encountered.

% ----------------------------------------------------------------------------
\defineentry{bad-arg}
\begin{procedure}
  \code{(bad-arg \var{who} \var{arg})}
\end{procedure}
\returns{} never

The \code{bad-arg} procedure raises exception \code{\#(bad-arg
  \var{who} \var{arg})}.

% ----------------------------------------------------------------------------
\defineentry{dump-stack}
\begin{procedure}
  \code{(dump-stack \opt{\var{op}})}\\
  \code{(dump-stack \var{k} \var{op} \var{max-depth})}\strut
\end{procedure}
\returns{} unspecified

The \code{dump-stack} procedure calls \code{walk-stack} to print information
about the stack to textual output port \var{op}, which defaults to the current
output port.

\var{k} is a continuation, and \var{max-depth} is either the symbol
\code{default} or a positive fixnum.
See \hyperlink{walk-stack}{\code{walk-stack}} for details on the
\var{max-depth} argument.

\code{(dump-stack \var{op})} calls \code{(call/cc (lambda (\var{k})
  (dump-stack \var{k} \var{op} 'default)))}.

% ----------------------------------------------------------------------------
\defineentry{limit-stack}
\begin{syntax}
  \code{(limit-stack \var{e0} \var{e1} \etc)}
\end{syntax}
\expandsto{}
\code{(\$limit-stack (lambda () \var{e0} \var{e1} \etc) \var{source})}

The \code{limit-stack} macro adds a stack frame that may be recognized
by \code{limit-stack?}.
By default, \code{walk-stack} avoids descending below such frames.
The \code{limit-stack} macro evaluates expressions \var{e0} \var{e1} \etc from
left to right and returns the values of the last expression.

% ----------------------------------------------------------------------------
\defineentry{limit-stack?}
\begin{procedure}
  \code{(limit-stack? \var{x})}
\end{procedure}
\returns{} see below

The \code{limit-stack?} procedure returns true if \var{x} is a continuation
whose top frame is a \code{limit-stack} frame.
Otherwise it returns \code{\#f}.

% ----------------------------------------------------------------------------
\defineentry{walk-stack}
\begin{procedure}
  \code{(\hypertarget{walk-stack}{walk-stack} \var{k} \var{base} \var{handle-frame} \var{combine} \opt{\var{who} \var{max-depth} \var{truncated}})}
\end{procedure}
\returns{} see below

The \code{walk-stack} procedure walks the stack of continuation \var{k}
by calling the \var{handle-frame} and \var{combine} procedures for each
stack frame until
it reaches the base of the stack or a \code{limit-stack} frame,
or depth reaches the optional \var{max-depth},
or the \var{next} argument to \var{combine} is not called.

The \var{handle-frame} procedure is called with four arguments:

\begin{tabular}{ll}
\var{description} & a string describing the stack frame, e.g., \code{"\#<continuation in g>"} \\
\var{source} & a source object identifying the return point or \code{\#f} \\
\var{proc-source} & a source object identifying the procedure containing the return point or \code{\#f} \\
\var{vars} & a list associating live free variables by name (or index) with their values
\end{tabular}

If \var{max-depth} is omitted or is the symbol \code{default}, then
\code{walk-stack} uses the value of \code{walk-stack-max-depth} as
\var{max-depth} and stops if recognizes a \code{limit-stack} frame.
If \var{max-depth} is specified explicitly, then \var{walk-stack}
does not stop at \code{limit-stack} frames.
If \code{walk-stack} reaches a depth of \var{max-depth}, it calls
the optional \var{truncated} procedure with \var{base} and \var{depth}.
Otherwise, \code{walk-stack} calls the \var{combine} procedure with four arguments:

\begin{tabular}{ll}
\var{frame} & the value returned by \var{handle-frame} for the current frame\\
\var{base} & the accumulator \\
\var{depth} & the zero-based depth of the current frame \\
\var{next} & a procedure that takes \var{base} and continues with the next frame
\end{tabular}

If \code{walk-stack} receives an invalid argument \var{val}, it calls
\code{(bad-arg \var{who} \var{val})} with
the symbol \code{walk-stack} as the default value for the
optional \var{who} argument.
The default \var{truncated} procedure simply returns the value of
\var{base} passed in.

% ----------------------------------------------------------------------------
\defineentry{walk-stack-max-depth}
\begin{parameter}
  \code{walk-stack-max-depth}
\end{parameter}
\returns{} a nonnegative fixnum

The \code{walk-stack-max-depth} parameter specifies the default maximum
depth to which \code{walk-stack} descends when the optional \var{max-depth}
argument is omitted or is the symbol \code{default}.

% ----------------------------------------------------------------------------
\defineentry{exit-reason->stacks}
\begin{procedure}
  \code{(exit-reason->stacks \var{x})}
\end{procedure}
\returns{} a list of continuations

The \code{exit-reason->stacks} procedure takes a Swish condition \var{x},
as created by \code{throw} or trapped by \code{try},
and returns a list of continuations recorded in \var{x}.
The continuations are listed innermost to outermost.

% -------------------------------------------------------------------------
\defineentry{make-process-parameter}
\begin{procedure}
  \code{(make-process-parameter \var{initial} \opt{\var{filter}})}
\end{procedure}
\returns{} a parameter procedure

The \code{make-process-parameter} procedure creates a parameter
procedure $p$ that provides mutable storage. Calling $p$ with no
arguments returns the current value of the parameter, and calling $p$
with one argument sets the value of the parameter. The \var{filter},
if present, is a procedure of one argument that is applied to the
\var{initial} and all subsequent values. If \var{filter} is not a
procedure, exception \code{\#(bad-arg make-process-parameter
  \var{filter})} is raised.

% -------------------------------------------------------------------------
\defineentry{reset-process-parameters"!}
\begin{procedure}
  \code{(reset-process-parameters!)}
\end{procedure}
\returns{} unspecified

The \code{reset-process-parameters!} procedure resets all process
parameters to their initial values.

% -------------------------------------------------------------------------
\defineentry{on-exit}
\begin{syntax}
  \code{(on-exit \var{finally} \var{b1} \var{b2} \etc{})}
\end{syntax}
\expandsto{}\begin{alltt}\antipar
(dynamic-wind
  void
  (lambda () \var{b1} \var{b2} \etc{})
  (lambda () \var{finally}))\end{alltt}

The \code{on-exit} macro executes the body expressions \var{b1}
\var{b2} \etc{} in a dynamic context that executes the \var{finally}
expression whenever control leaves the body.

% ----------------------------------------------------------------------------
\defineentry{profile-me}
\begin{procedure}
  \code{(profile-me)}
\end{procedure}
\returns{} unspecified

The \code{profile-me} procedure does nothing but provide a
place-holder for the system profiler to count the call site. When
profiling is turned off, \code{(profile-me)} expands to
\code{(void)}, and the system optimizer eliminates it.

% ----------------------------------------------------------------------------
\defineentry{profile-me-as}
\begin{syntax}
  \code{(profile-me-as \var{form})}
\end{syntax}
\returns{} unspecified

The \code{profile-me-as} macro does nothing but provide a
place-holder for the system profiler to count the call site.
If source information is present on \var{form}, the profile count
for this call site is attributed to that \var{form}.
When profiling is turned off or when source information is not
present on \var{form}, \code{profile-me-as} expands to
\code{(void)}, and the system optimizer eliminates it.

% ----------------------------------------------------------------------------
\defineentry{windows?}
\begin{syntax}
  \code{windows?}
\end{syntax}
\expandsto{} a boolean

The \code{windows?} macro expands to \code{\#t} if the host is running
Microsoft Windows and \code{\#f} if not.

% ----------------------------------------------------------------------------
\subsection {I/O}

% ----------------------------------------------------------------------------
\defineentry{binary->utf8}
\begin{procedure}
  \code{(binary->utf8 \var{bp})}
\end{procedure}
\returns{} a transcoded textual port wrapping \var{bp}

The \code{binary->utf8} procedure takes a binary port \var{bp} and
returns a textual port wrapping \var{bp} using
\code{transcoded-port} and \code{(make-utf8-transcoder)}. The
original port \var{bp} is marked closed so that it cannot be used
except through the associated textual port.

% ----------------------------------------------------------------------------
\defineentry{make-utf8-transcoder}
\begin{procedure}
  \code{(make-utf8-transcoder)}
\end{procedure}
\returns{} a UTF-8 transcoder

The \code{make-utf8-transcoder} procedure creates a UTF-8 transcoder
with end-of-line style \code{none} and error-handling mode
\code{replace}.

% ----------------------------------------------------------------------------
\defineentry{path-absolute}
\begin{procedure}
  \code{(path-absolute \var{path} \opt{\var{base}})}
\end{procedure}
\returns{} a string

The \code{path-absolute} procedure returns the normalized absolute path of \var{path}
relative to the \var{base} directory, which defaults to the current directory.

% ----------------------------------------------------------------------------
\defineentry{path-combine}
\begin{procedure}
  \code{(path-combine \var{path$_1$} \var{path$_2$} \etc{})}
\end{procedure}
\returns{} a string combining the paths

The \code{path-combine} procedure appends one or more paths, inserting
the directory-separator character between each pair of paths as
needed.

% ----------------------------------------------------------------------------
\defineentry{path-normalize}
\begin{procedure}
  \code{(path-normalize \var{path})}
\end{procedure}
\returns{} a string with the normalized path

The \code{path-normalize} procedure removes unnecessary directory separators and
simplifies ``.'' and ``..'' components from \var{path}.

% ----------------------------------------------------------------------------
\subsection{Error Strings}

% ----------------------------------------------------------------------------
\defineentry{current-exit-reason->english}
\begin{parameter}
  \code{current-exit-reason->english}
\end{parameter}
\hasvalue{} a procedure of one argument that returns an English string

The \code{current-exit-reason->english} parameter specifies the
conversion procedure used by \code{exit-reason->english}. It defaults
to \code{swish-exit-reason->english}.

% ----------------------------------------------------------------------------
\defineentry{exit-reason->english}
\begin{procedure}
  \code{(exit-reason->english \var{x})}
\end{procedure}
\returns{} a string in U.S. English

The \code{exit-reason->english} procedure converts an exit reason into
an English string using the procedure stored in parameter
\code{current-exit-reason->english}.

% ----------------------------------------------------------------------------
\defineentry{swish-exit-reason->english}
\begin{procedure}
  \code{(swish-exit-reason->english \var{x})}
\end{procedure}
\returns{} a string in U.S. English

The \code{swish-exit-reason->english} procedure converts an exit
reason from Swish into an English string.

% ----------------------------------------------------------------------------
\subsection{String Utilities}

The string utilities below are found in the \code{(swish
  string-utils)} library.

% ----------------------------------------------------------------------------
\defineentry{ct:join}
\begin{syntax}
  \code{(ct:join \var{sep} \var{s} \etc{})}
\end{syntax}
\expandsto{} a string or a call to \code{string-append}

The \code{ct:join} macro uses \code{ct:string-append} to join adjacent string
literals into a literal string or a call to \code{string-append} where adjacent
string literals are combined.
The \var{sep}, which must be a literal string or character, is inserted
between adjacent elements of \var{s}~\etc{}.

% ----------------------------------------------------------------------------
\defineentry{ct:string-append}
\begin{syntax}
  \code{(ct:string-append \var{s} \etc{})}
\end{syntax}
\expandsto{} a string or a call to \code{string-append}

The \code{ct:string-append} macro appends adjacent string literals
at compile time and expands into the resulting literal string or a
call to \code{string-append} where adjacent string literals are
combined.

% ----------------------------------------------------------------------------
\defineentry{ends-with?}
\begin{procedure}
  \code{(ends-with? \var{s} \var{p})}
\end{procedure}
\returns{} a boolean

The \code{ends-with?} procedure determines whether or not the string
\var{s} ends with string \var{p} using case-sensitive comparisons.

% ----------------------------------------------------------------------------
\defineentry{ends-with-ci?}
\begin{procedure}
  \code{(ends-with-ci? \var{s} \var{p})}
\end{procedure}
\returns{} a boolean

The \code{ends-with-ci?} procedure determines whether or not the
string \var{s} ends with string \var{p} using case-insensitive
comparisons.

% ----------------------------------------------------------------------------
\defineentry{format-rfc2822}
\begin{procedure}
  \code{(format-rfc2822 \var{d})}
\end{procedure}
\returns{} a string like ``Thu, 28 Jul 2016 17:20:11 -0400''

The \code{format-rfc2822} procedure returns a string representation of
the date object \var{d} in the form specified in Section 3.3 of RFC
2822~\cite{RFC2822}.

% ----------------------------------------------------------------------------
\defineentry{join}
\begin{procedure}
  \code{(join \var{ls} \var{separator} \opt{\var{last-separator}})}
\end{procedure}
\returns{} a string

The \code{join} procedure returns the string formed by displaying each
of the elements of list \var{ls} separated by displaying
\var{separator}. When \var{last-separator} is specified, it is used as
the last separator.

% ----------------------------------------------------------------------------
\defineentry{oxford-comma}
\begin{procedure}
  \code{(oxford-comma \opt{\var{prefix}} \var{elt-fmt} \var{conj} \opt{\var{suffix}})}
\end{procedure}
\returns{} a string

The \code{oxford-comma} procedure constructs a format string for use with
\code{errorf}, \code{format}, \code{printf}, etc., to join the elements
of a list with commas and/or \var{conj}, as appropriate.
The \var{elt-fmt} argument is the format string for individual
items of the list.
The \var{conj} argument is a string used to separate the final two elements
of the list.
The \var{prefix} and \var{suffix} arguments must be supplied together or
omitted.
If omitted, \var{prefix} defaults to \code{\fixtilde"~\{"} and \var{suffix}
defaults to \code{\fixtilde"~\}"}.

% ----------------------------------------------------------------------------
\defineentry{split}
\begin{procedure}
  \code{(split \var{str} \var{separator})}
\end{procedure}
\returns{} a list of strings

The \code{split} procedure divides the \var{str} string by the
\var{separator} character into a list of strings, none of which
contain \var{separator}.

% ----------------------------------------------------------------------------
\defineentry{split-n}
\begin{procedure}
  \code{(split-n \var{str} \var{separator} \var{n})}
\end{procedure}
\returns{} a list of no more than \var{n} strings

The \code{split-n} procedure divides the \var{str} string by the
\var{separator} character into a list of at most \var{n} strings. The
last string may contain \var{separator}.

% ----------------------------------------------------------------------------
\defineentry{starts-with?}
\begin{procedure}
  \code{(starts-with? \var{s} \var{p})}
\end{procedure}
\returns{} a boolean

The \code{starts-with?} procedure determines whether or not the string
\var{s} starts with string \var{p} using case-sensitive comparisons.

% ----------------------------------------------------------------------------
\defineentry{starts-with-ci?}
\begin{procedure}
  \code{(starts-with-ci? \var{s} \var{p})}
\end{procedure}
\returns{} a boolean

The \code{starts-with-ci?} procedure determines whether or not the
string \var{s} starts with string \var{p} using case-insensitive
comparisons.

% ----------------------------------------------------------------------------
\defineentry{trim-whitespace}
\begin{procedure}
  \code{(trim-whitespace \var{s})}
\end{procedure}
\returns{} a string

The \code{trim-whitespace} procedure returns a string in which
any leading or trailing whitespace in \var{s} has been removed.
Internal whitespace is not affected.

% ----------------------------------------------------------------------------
\defineentry{wrap-text}
\begin{procedure}
  \code{(wrap-text \var{op} \var{width} \var{initial-indent} \var{subsequent-indent} \var{text})}
\end{procedure}
\returns{} unspecified

The \code{wrap-text} procedure writes the given \var{text} to the textual output
port \var{op} after collapsing spaces that separate words. The first line is
indented by \var{initial-indent} spaces. Subsequent lines are indented by
\var{subsequent-indent} spaces. If possible, \code{wrap-text} breaks lines that
would exceed \var{width}. Newlines and tabs are preserved, but tabs are
treated as if they were the width of a single character.

The \var{text} argument may be a string or a list of strings. If \var{text}
is a list, it is treated as if it were the string obtained via \code{(join \var{text} \#{\textbackslash}space).}

% ----------------------------------------------------------------------------
\defineentry{symbol-append}
\begin{procedure}
  \code{(symbol-append . \var{ls})}
\end{procedure}
\returns{} a symbol

The \code{symbol-append} procedure returns the symbol formed by
appending the symbols passed as arguments.

% ----------------------------------------------------------------------------
\subsection{Macro Utilities}

% ----------------------------------------------------------------------------
\defineentry{pretty-syntax-violation}
\begin{procedure}
  \code{(pretty-syntax-violation \var{msg} \var{form} \opt{\var{subform} \opt{\var{who}}})}
\end{procedure}
\returns{} never

The \code{pretty-syntax-violation} procedure raises a syntax violation.
It differs from the native \code{syntax-violation} in that it formats
\var{form} and \var{subform} using \code{pretty-format} abbreviations,
and it does not attempt to infer a who condition when \var{who} is not
provided, as this can produce confusing results in error messages
involving match patterns.
To provide more readable exception messages, it constructs the formatted
message condition by calling \code{pretty-print} before raising the exception,
and it prevents \code{display-condition} from formatting the \code{\&syntax}
condition within the compound condition it constructs.

% ----------------------------------------------------------------------------
\defineentry{with-temporaries}
\begin{syntax}
  \code{(with-temporaries (\var{id} ...) e0 e1 ...)}
\end{syntax}
\expandsto{}\begin{alltt}\antipar
(with-syntax ([(id ...) (generate-temporaries '(id ...))])
  e0 e1 ...)\end{alltt}

The \code{with-temporaries} macro binds each macro-language
pattern variable \var{id} to a fresh generated identifier
within the body \code{(begin \var{e0}\ \var{e1}\ ...)}.
